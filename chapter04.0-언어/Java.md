# Java

## Java의 특징에 대해 설명하시오.
- 이식성이 높은 언어이다.
- 객체 지향 언어이다.
- 함수적 스타일 코딩을 지원한다.
- 메모리를 자동으로 관리한다.
- 다양한 애플리케이션을 개발할 수 있다.
- 멀티 스레드(Multi-Thread)를 쉽게 구현할 수 있다.
- 동적 로딩(Dynamic Loading)을 지원한다.
- 오픈소스 라이브러리가 풍부하다.
---
## Java의 컴파일 과정에 대해 설명하시오.
- 자바 프로그램은 확장자가 .java 파일을 작성하는 것부터 시작된다. 이것을 소스 파일이라고 한다.
- 소스 파일을 컴파일러(javac.exe)로 컴파일하면 확장자가 .class인 바이트 코드 파일이 생성된다.
- 바이트 코드 파일은 JVM 구동 명령어(java.exe)에 의해 해석되고 해당 운영체제에 맞게 기계어로 번역된다.
- 바이트 코드는 하나지만 JVM에 의해 번역되는 기계어는 운영체제에 따라 달라진다.
---
## JVM의 구조에 대해 설명하시오.
- Java Classloader
  > 자바 클래스(*.class)를 자바 가상 머신(JVM)으로 동적 로드 하는 자바 런타임 환경(JRE)의 일부이다.
  - JVM Memory(Runtime Data Area) : 클래스로더에 의해 데이터가 적재되는 공간이다.
    - 메소드 영역(Method Area)
      > 코드에서 사용되는 클래스들을 클래스로더로 읽어 클래스별로 분류하여 저장한다. 메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다.
    - 힙 영역(Heap Area)
      > 객체와 배열이 생성되는 영역이다. JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다. 참조하는 변수나 필드가 없다면 의미가 없으므로 Garbage Collector가 쓰레기 객체를 힙 영역에서 자동으로 제거한다. 
    - JVM 스택(Stack)
      > 각 스레드마다 하나씩 존재하며 스레드가 시작될 때 할당된다. 메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다. 프레임 내부에는 로컬 변수 스택이 존재할 수 있다.
    - PC Registers
      > 실행될 명령의 주소(address)를 가지고 있다.
    - Native Method Stacks
      > 스레드에서 네이티브 방식의 메소드가 실행되면 해당 스택에 쌓인다. C언어로 작성된 메소드가 이에 해당된다.
- Execution Engine
  > 클래스로더에 의해 JVM 메모리 공간에 적재된 바이트 코드를 실행하기 전에 기계어로 변경 후 사용한다. 변견 방법에는 Interpreter와 JIT(Just-In-Time) compiler가 있다.
- Native Method Interface
- Native Method Libraries
---
## Garbage Collection의 동작 흐름에 대해 설명하시오.
- Garbage Collector라는 데몬 스레드에 의해 실행되며 대상이 되는 객체를 힙에서 제거한다.
- 객체를 메모리에서 제거하기 전 해당 객체의 finalize() 메소드를 호출한다.
- GC는 강제로 수행할 수 없다. JVM이 힙 사이즈에 기반해 필요한 경우만 수행한다.
- System.gc()와 Runtime.gc()는 GC를 실행시키지 않고 권유하므로 실행이 보장되지 않는다.
- 힙에 새로운 객체를 생성할 메모리가 없다면 Out Of Memory Error를 출력한다.
---
## Java의 Data Type에 대해 설명하시오.
### 기본 데이터 타입
> 정수, 실수, 문자, 논리 리터럴을 직접 저장하는 타입이다.

값의 종류 | 기본 타입 | 메모리 사용 크기
---------|----------|---------
 정수 | byte | 1byte, 8bit
 정수 | char | 2byte, 16bit
 정수 | short | 2byte, 16bit
 정수 | int | 4byte, 32bit
 정수 | long | 8byte, 64bit
 실수 | float | 4byte, 32bit
 실수 | double | 8byte, 64bit
 논리 | boolean | 1byte, 8bit
---
### 데이터 변환
> 데이터 타입을 다른 데이터 타입으로 변환하는 것이다.

- 자동 타입 변환(Promotion)
  > 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것이다.
  >> 작은 크기를 가지는 타입이 큰 크기를 가지는 타입에 저장될 때 발생한다.
- 강제 타입 변환(Casting)
  > 큰 크기의 타입은 작은 크기의 타입으로 자동 타입 변환할 수 없다.
  >> 그러나 큰 크기를 작은 크기로 쪼개면 가능하다. (8byte -> 4byte)
---
## Object에 대해 설명하시오.
- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다.
- 객체는 속성과 동작으로 구성되어 있다. 이를 필드(field)와 메소드(method)라고 한다.
- 현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 객체 모델링(Object Modeling)이라고 한다.
---
## 캡슐화에 대해 설명하시오.
- 객체의 필드, 메소드를 하나로 묶어 실제 구현 내용을 감추는 것이다.
  - 외부 객체는 객체 내부 구조를 알지 못하며 객체가 제공하는 필드와 메소드만 이용할 수 있다.
- 필드와 메소드를 캡슐화로 보호하는 이유
  - 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하기 때문이다.
  - 자바는 접근 제한자(Access Modifier)를 사용해 캡슐화 멤버를 노출할지 은닉할지 결정할 수 있다.
---
## 상속에 대해 설명하시오.
- 부모가 가지고 있는 성질을 자식에게 물려주는 것이다.
- 상위 객체를 재사용하여 하위 객체를 쉽고 빨리 설계할 수 있도록 도와준다.
  - 반복되는 코드의 중복을 줄여준다.
  - 개발 시간을 절약할 수 있다.
  - 유지 보수 시간을 최소화할 수 있다.
---
## 다형성에 대해 설명하시오.
- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질이다.
- 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다.
- 부모 타입에는 모든 자식 객체가, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다.
  - 다형성의 효과로 객체는 부품화가 가능하다.
---
## 객체와 클래스에 대해 설명하시오.
> 객체를 생성하는 순서
>> 개발자 -> (설계) -> 클래스(설계도) -> (인스턴스화) -> 인스턴스(객체)
- 자바에서의 설계도는 클래스이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다.
- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다.
- 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.
  - 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있다.
---
## Static에 대해 설명하시오.
- static은 '정적'이라는 의미이다.
- 정적 변수와 정적 메소드를 선언하는데 사용된다.
- static 키워드를 붙이면 자바는 메모리 할당을 1회만 수행하며 메모리 사용에 이점을 얻는다.
  - 같은 곳의 메모리 주소만을 바라보므로 static 변수의 값을 공유한다.
  - 메모리의 효율을 위해 static을 사용하기보단 공유의 목적으로 많이 사용한다.
- 메소드에 static 키워드를 붙이면 해당 메소드의 안에서는 인스턴스 변수 접근이 불가능하다.
  - static 변수만이 static 메소드에 접근할 수 있다.
  - 이러한 메소드는 유틸리티 메소드를 작성할 때 많이 사용된다.
- static은 Singleton 패턴과 관련이 깊다.
---
## Access Modifier에 대해 설명하시오.
- 라이브러리 클래스는 외부 클래스에서 접근할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 설계해야 한다.
  - 객세 생성을 막기 위해 생성자를 호출하지 못하게 한다.
  - 객체의 특정 데이터를 보호하기 위해 해당 필드에 접근하지 못하게 한다.
  - 특정 메소드를 호출할 수 없도록 제한할 필요가 있다.
- 이러한 기능을 구현하기 위한 것이 접근제한자(Access Modifier)이다.

접근 제한 | 적용대상 | 접근할 수 없는 클래스
------- | ------- | -------
public | 클래스, 필드, 생성자, 메소드 | 없음
protected | 필드, 생성자, 메소드 | 자식 클래스가 아닌 다른 패키지에 소속된 클래스
default | 클래스, 필드, 생성자, 메소드 | 다른 패키지에 소속된 클래스
private | 필드, 생성자, 메소드 | 모든 외부 클래스
---
## Interface와 Abstract class의 차이점
- 인터페이스
  - 클래스가 아니다.
  - 클래스와 관련이 없다.
  - 한 개의 클래스에 여러 개의 인터페이스를 구현할 수 있다.
  - **구현 객체의 같은 동작을 보장하기 위해 사용된다.**
- 추상 클래스
  - 클래스이다.
  - 클래스와 관련이 있으며 Factory Method 패턴과 관련이 깊다.
  - 한 개의 클래스는 하나의 추상 클래스만을 상속한다.
  - **상속을 강제하여 기능을 확장하기 위해 사용된다.**
---
## [Annotation에 대해 설명하시오.](Annotation.md)
---
## Overloading과 Overriding의 차이점
- 오버라이딩(Overriding)
  - 상위 클래스에 존재하는 메소드를 하위 클래스에서 필요에 맞게 재정의하는 것을 의미한다.
- 오버로딩(Overloading)
  -  상위 클래스의 메소드와 이름, return 값은 동일하지만, 매개변수만 다른 메소드를 만드는 것을 의미한다.
---
## == 연산자와 equals() 메소드의 차이점
- 연산자와 메소드로 개념이 다르다.
  - == : 대상의 주소값을 비교한다.
  - equals() : 대상의 값을 비교한다.
---
## equals와 hashCode()에 대해 설명하시오.
- equals() : 두 객체의 내용이 같은지 확인하는 메소드이다.
- hashCode() : 두 객체가 같은 객체인지 확인하는 메소드이다.
  - 해당 객체가 메모리에서 가지는 해쉬 주소값을 반환한다.
---
## Reflection에 대해 설명하시오.
- Class 객체를 이용하면 클래스의 생성자, 필드, 메소드 정보를 알아낼 수 있는데, 이것이 리플렉션이다.
  - class 객체는 getDeclaredConstructors(), getDeclaredFields(), getDeclaredMethods()를 제공한다.
  - 세 메소드는 각각 Constructor 배열, Field 배열, Method 배열을 리턴한다.
  - 단지 위의 세 메소드는 클래스에 선언된 멤버만 가져오고 상속된 멤버는 가져오지 않는다.
    - 상속 멤버를 얻고 싶다면 getFields(), getMethods()를 사용한다. 단, public 멤버만 가져온다.
---
## String, StringBuffer, StringBuilder의 차이점
### String
- 문자열을 저장하는 String은 내부 문자열을 수정할 수 없다. replace()의 경우 내부 문자를 대치하는 것이 아니라 대치된 새로운 문자열을 리턴하는 것이다.
  - 객체의 내부 데이터를 수정할 수 없으므로 새로운 String 객체를 생성하는 것이다.
- 문자열을 결합하는 + 연산자를 많이 사용하면 String 객체의 수가 늘어나 프로그램 성능을 느리게 한다.
  - 따라서 문자열 변경이 많을 때는 StringBuffer와 StringBuilder 클래스를 권장한다.
  - 두 클래스는 내부 버퍼(buffer : 데이터를 임시로 저장하는 메모리)에 문자열을 저장한다.
    - buffer 안에서 추가, 수정, 삭제 작업을 할 수 있도록 설계되었다.
---
### StringBuffer, StringBuilder
- 두 클래스의 사용방법은 동일하다.
  - StringBuffer는 멀티 스레드 환경에서 사용할 수 있도록 동기화가 적용되어 있어 스레드에 안전하다.
  - StringBuilder는 단일 스레드 환경에서만 사용하도록 설계되어 있다.
- 문자열을 수정하면서 메모리가 부족할 경우 자동으로 버퍼 크기를 늘린다.
---
## Thread에 대해 설명하시오.
- 일반 스레드와 거의 차이가 없으며, JVM가 운영체제의 역할을 한다.
- 자바에는 프로세스가 존재하지 않고 스레드만 존재하며, 자바 스레드는 JVM에 의해 스케줄되는 실행 단위 코드 블록이다.
- 자바에서 스레드 스케줄링은 전적으로 JVM에 의해 이루어진다.
- 아래와 같은 스레드와 관련된 많은 정보들도 JVM이 관리한다.
  - 스레드가 몇 개 존재하는지
  - 스레드로 실행되는 프로그램 코드의 메모리 위치는 어디인지
  - 스레드의 상태는 무엇인지
  - 스레드 우선순위는 얼마인지
- **개발자는 자바 스레드로 작동할 스레드 코드를 작성하고, 스레드 코드가 생명을 가지고 실행을 시작하도록 JVM에 요청하는 일 뿐이다.**
---
## 동기화 메소드(Synchronized Method)에 대해 설명하시오.
- 사용 중인 객체를 다른 스레드가 변경할 수 없도록 하려면 작업이 끝날 때까지 객체에 잠금을 걸어야 한다.
  - 단 하나의 스레드만 실행할 수 있는 코드 영역을 임계 영역(critical section)이라고 한다.
  - 자바는 임계 영역을 지정하기 위해 동기화(synchronized method) 메소드와 동기화 블록을 제공한다.
  - 동기화 메소드를 만드는 방법은 메소드 선언에 synchronized 키워드를 붙이면 된다.
  - 일부 내용만 임계 영역으로 지정하고 싶다면 동기화 블록을 만들면 된다.
---
## Generic에 대해 설명하시오.
- 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있게 한다.
- 클래스와 인터페이스, 메소드를 정의할 때 타입(type)을 파라미터(parameter)로 사용할 수 있도록 한다.
- 장점
  - 컴파일 시 강한 타입 체크를 할 수 있다.
    - 실행 시의 타입 에러보다 컴파일 시 미리 타입을 강하게 체크하여 에러를 사전에 방지한다.
  - 타입 변환(casting)을 제거한다.
    - 비제네릭 코드는 불필요한 타입 변환을 하기 때문에 프로그램 성능에 악영향을 미친다.
---
## Collection Framework에 대해 설명하시오.
- 다수의 객체를 저장할 필요가 있을 경우 배열을 사용한다.
  - 배열은 생성 시 크기가 정해지므로 불특정 다수의 객체를 저장하기엔 문제가 있었다.
  - 또한, 객체를 삭제했을 때 해당 인덱스가 비어버리는 문제점도 있었다.
- 위의 문제를 해결하고 객체들을 효율적으로 추가, 삭제, 검색 할 수 있어야 했다.
- 따라서, 자료구조(DataStructure)를 바탕으로 java.util 패키지에 컬렉션과 관련된 인터페이스와 클래스를 포함시켜 놓고 이들을 컬렉션 프레임워크(Collection Framework)라고 부른다.
---
## List의 종류에 대해 설명하시오.
- 순서를 유지하고 저장한다.
- 중복 저장이 가능하다.
- 구현 클래스
  - ArrayList
  - Vector
  - LinkedList
---
## Set의 종류에 대해 설명하시오.
- 순서를 유지하지 않고 저장한다.
- 중복 저장이 불가능하다.
- 구현 클래스
  - HashSet
  - TreeSet(SortedSet)
---
## Map의 종류에 대해 설명하시오.
- 키와 값의 쌍으로 저장한다.
- 키는 중복으로 저장할 수 없다.
- 구현 클래스
  - HashMap
  - HashTable
  - TreeMap(SortedMap)
  - Properties
---
## Vector와 ArrayList의 차이점
- ArrayList와 동일한 내부 구조를 가지고 있지만 Vector는 동기화된(Synchronized) 메소드로 구성되어 있다.
  - 멀티 스레드가 동시에 이 메소드들을 실행할 수 없다.
  - 하나의 스레드가 실행을 완료해야만 다른 스레드를 실행할 수 있다.
  - 위의 이유로 멀티 스레드 환경에서 안전하게 객체를 추가, 삭제할 수 있다.
  - 이것을 스레드가 안전(Thread Safe)하다고 한다.
---
## Serialization에 대해 설명하시오.
- 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술과 바이트로 변환된 데이터를 다시 객체로 변환하는 기술(역직렬화)이다.
- JVM(Java Virtual Machine 이하 JVM)의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술과 직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태이다.
- CSV, JSON의 형태를 가장 많이 사용한다.
---
## Java와 Javascript의 차이점
- Java : Server 측의 프로그래밍에 사용되는 객체 지향 언어이다.
- JavaScript : 웹프로그래밍을 위한 스크립트 언어이다.
- 구문의 유사성을 제외하고는 관련성이 없다. Java는 기술은 웹서버, JavaScript는 클라이언트 측에서 사용한다.
---
## 성능을 개선하기 위해 어떤 방법을 사용하는가
---
## 소수 혹은 큰 숫자를 정확히 계산하는 방법
---