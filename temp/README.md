# 정보처리기사 *(실기)* 커리큘럼

# 목차별 정리
## 프로그래밍 언어 활용
### 데이터 타입 B
### 변수 A
> 값을 저장하기 위한 공간으로 변할 수 있는 값을 의미
> - 정수형, 실수형, 문자형, 포인터형 등으로 구분

- 변수명 작성 규칙
  - 영문자, 숫자, _(under bar) 사용 가능
  - 첫 글자는 영문자나 _로 시작해야 하며, 숫자는 올 수 없음
  - 글자 수에 제한 없음
  - 공백, *, +, -, / 등의 특수문자는 사용 불가능
  - 대소문자 구분
  - 예약어를 변수명으로 사용할 수 없음
  - 변수 선언 시 문장 끝에는 세미콜론을 붙임
    - Python은 예외

- 예약어
  - 정해진 기능을 수행하도록 이미 정해진 단어
  - 변수나 다른 용도로 사용 불가능
  - for, case, break, char, auto, const 등

- 기억 클래스
  - 변수 선언 시 메모리 내에 변수의 값을 저장하기 위한 기억영역이 할당됨
  - 할당되는 기억영역에 따라 사용 범위에 제한이 있으며, 기억 영역을 결정하는 작업을 기억 클래스라고 함
  - 자동 변수
    - 함수나 블록 내에서 선언되는 변수
    - 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸
    - 초기화하지 않으면 쓰레기값이 저장됨
  - 외부변수
    - 현재 혹은 다른 파일에서 선언된 변수나 함수를 참조하기 위한 변수
    - 외부 변수는 함수 밖에서 선언
    - 함수가 종료된 뒤에도 값이 소멸되지 않음
    - 다른 파일에 선언된 변수는 초기화할 수 없음
  - 정적 변수
    - 내부 정적 변수 : 선언한 함수나 블록 내에서만 사용할 수 있음
    - 외부 정적 변수 : 모든 함수에서 사용 가능
    - 두 변수 모두 함수나 블록이 종료된 뒤에도 값이 소멸되지 않음
    - 초기화는 변수 선언 시 한 번만 할 수 있으며 초기화를 생략하면 0으로 자동 초기화
  - 레지스터 변수
    - 메모리가 아닌 CPU 내부의 레지스터에 기억영역을 할당받는 변수
    - 자주 사용되는 변수를 레지스터에 저장해 처리 속도를 높이기 위해 사용
    - 함수나 블록이 실행되는 동안에만 존재하며 이를 벗어나면 자동으로 소멸
    - 레지스터의 사용 개수는 한정되어 있어 저장할 레지스터가 없으면 자동 변수로 취급되어 메모리에 할당
    - CPU에 저장되므로 메모리 주소를 가지지 않기에 주소 연산자(&)를 사용할 수 없음

- 단정도 / 배정도
  - float 자료형은 단정도형, double과 long 자료형은 배정도형이라고 표현
  - 1.23e-2 : e는 10의 지수승을 의미하므로 1.23 x 10^-2, 즉 0.0123을 의미

<br>

### 데이터 입출력 A
> 표준 입출력 함수 : 키보드로 입력받아 화면으로 출력할 때 사용하는 함수
> - scanf(), getchar(), gets(), printf(), putchar(), puts() 등이 존재 *(C언어)*

- scanf(서식 문자열, 주소) 함수 : C언어의 표준 입력 함수
  - 특징
    - 입력받을 데이터의 자료형, 자릿수 등을 지정할 수 있음
    - 한 번에 여러 개의 데이터를 입력 받을 수 있음
    - 서식 문자열과 변수의 자료형은 일치해야 함
  - 서식 문자열

    |서식문자열|의미|
    |----------|----|
    |%d|정수형 10진수를 입출력하기 위해 지정|
    |%u|부호없는 정수형 10진수를 입출력하기 위해 지정|
    |%o|정수형 8진수를 입출력하기 위해 지정|
    |%x|정수형 16진수를 입출력하기 위해 지정|
    |%c|문자를 입출력하기 위해 지정|
    |%s|문자열을 입출력하기 위해 지정|
    |%f|소수점을 포함하는 실수를 입출력하기 위해 지정|
    |%e|지수형 실수를 입출력하기 위해 지정|
    |%ld|long형 10진수를 입출력하기 위해 지정|
    |%lo|long형 8진수를 입출력하기 위해 지정|
    |%lx|long형 16진수를 입출력하기 위해 지정|
    |%p|주소를 16진수로 입출력하기 위해 지정|

- printf(서식 문자열, 변수) 함수 : C언어의 표준 출력 함수
  - 주요 제어문자

    |문자|의미|기능|
    |----|----|----|
    |\n|new line|커서를 다음 줄 앞으로 이동|
    |\b|backspace|커서를 왼쪽으로 한 칸 이동|
    |\t|tab|커서를 일정 간격 띄움|
    |\r|carriage return|커서를 현재 줄의 처음으로 이동|
    |\0|null|널 문자를 출력|
    |\'|single quote|작은따옴표 출력|
    |\"|double quote|큰따옴표 출력|
    |\a|alert|스피커로 벨 소리를 출력|
    |\\|backslash|역 슬래시를 출력|
    |\f|form feed|한 페이지를 넘김|

- 기타 표준 입출력 함수
  - 입력
    - getchar()
      - 키보드로 한 문자를 입력받아 변수에 저장하는 함수
    - gets()
      - 키보드로 문자열을 입력받아 변수에 저장하는 함수
      - Enter를 누르기 전까지를 하나의 문자열로 인식하여 저장
  - 출력
    - putchar()
      - 인수로 주어진 한 문자를 화면에 출력하는 함수
    - puts()
      - 인수로 주어진 문자열을 화면에 출력한 후 커서를 자동으로 다음 줄 앞으로 이동하는 함수

<br>

### 연산자 A
- 산술 연산자 : 산술 계산에 사용되는 연산자

  |연산자|의미|
  |------|----|
  |+|덧셈|
  |-|뺄셈|
  |*|곱셈|
  |/|나눗셈|
  |%|나머지|
  |++|증가 연산자|
  |--|감소 연산자|

  - 전치 : 먼저 변수의 값을 증감시킨 후 변수를 연산에 사용
    - ++a, --a
  - 후치 : 먼저 변수를 연산에 사용한 후 변수의 값을 증감
    - a++, a--

- 관계 연산자 : 두 수의 관계를 비교하여 참 또는 거짓을 결과로 얻는 연산자

  |연산자|의미|
  |------|----|
  |==|같다|
  |!=|같지 않다|
  |>|크다|
  |>=|크거나 같다|
  |<|작다|
  |<=|작거나 같다|

- 비트 연산자 : 비트별(0, 1)로 연산하여 결과를 얻는 연산자

  |연산자|의미|비고|
  |------|----|----|
  |&|and|모든 비트가 1일때만 1|
  |^|xor|모든 비트가 같으면 0, 하나라도 다르면 1|
  |`|`|or|모든 비트 중 한 비트라도 1이면 1|
  |~|not|각 비트의 부정, 0이면 1, 1이면 0|
  |<<|왼쪽 시프트|비트를 왼쪽으로 이동|
  |>>|오른쪽 시프트|비트를 오른쪽으로 이동|

- 논리 연산자 : 두 개의 논리 값을 연산하여 참 또는 거짓을 결과로 얻는 연산자

  |연산자|의미|비고|
  |------|----|----|
  |!|not|부정|
  |&&|and|모두 참이면 참|
  |`||`|or|하나라도 참이면 참|

- 대입 연산자 : 연산 후 결과를 대입하는 연산식을 간략하게 입력할 수 있게 하는 연산자

  |연산자|예|의미|
  |------|--|----|
  |+=|a += 1|a = a + 1|
  |-=|a -= 1|a = a - 1|
  |*=|a *= 1|a = a * 1|
  |/=|a /= 1|a = a / 1|
  |%=|a %= 1|a = a % 1|
  |<<=|a <<= 1|a = a << 1|
  |>>=|a >>= 1|a = a >> 1|

- 조건 연산자 : 조건에 따라 서로 다른 수식을 수행
  > 조건 ? 수식1 : 수식2

- 연산자 우선순위
  - 증감 연산자
  - 산술 연산자 * / 
  - 산술 연산자 + -
  - 시프트 연산자
  - 관계 연산자 < <= >= >
  - 관계 연산자 == !=
  - 비트 연산자 &
  - 비트 연산자 ^
  - 비트 연산자 |
  - 논리 연산자 &&
  - 논리 연산자 ||
  - 조건 연산자
  - 대입 연산자
  - 순서 연산자

<br>

### 제어문 A
> 프로그램의 순서를 변경할 때 사용하는 명령문

- 단순 if문
  - 형식1, 조건이 참일 때만 실행
  - 형식2, 조건이 참일 때와 거짓일 때 실행

- 다중 if문
  - 조건이 여러 개일 때 사용

- switch문
  - 조건에 따라 분기할 곳이 여러 곳일 때 사용
  - case문의 레비을은 한 개의 상수만 지정하고, int, char, enum형 상수만 가능
  - default문은 가장 마지막에 사용되고 다음 문자에서 바로 종료되므로 break를 사용할 필요가 없음

- goto문
  - 현재 위치에서 원하는 다른 문장으로 건너뛰어 수행을 계속하기 위해 사용
  - 많이 사용하면 프로그램의 이해와 유지 보수가 어려워저 거의 사용하지 않음

<br>

### 반복분 A
> 제어문의 한 종류로 일정한 횟수를 반복하는 명령문

- for문
  - 초기값, 최종값, 증가값을 지정하는 수식을 이용해 정해진 횟수를 반복
  - 최종값에 대한 조건이 참인 동안 실행할 문장을 반복 수행
  - for( ; ; )와 같이 조건에 참여하는 수식을 모두 생략하면 for문을 무한 반복
  - 처음부터 최종값에 대한 조건식을 만족하지 못하면 한 번도 수행하지 않음
  - 문자도 for문을 수행할 수 있음

- while문
  - 조건이 참인 동안 실행할 문장을 반복 수행
  - 조건이 처음부터 거짓이면 한 번도 사용하지 않음

- do~while문
  - while문과 같은 동작
  - 단, 실행할 문장을 무조건 한 번 실행한 다음 조건을 판단하여 탈출 여부를 결정

- break, continue
  - switch문과 반복문의 실행을 제어하기 위해 사용되는 예약어
  - break : switch문이나 반복문 내부에서 break가 나오면 블록을 벗어남
  - continue
    - continue 이후의 문장을 실행하지 않고 제어를 반복문의 처음으로 이동
    - 반복문에서만 사용

<br>

### 배열과 문자열 A
> 동일한 데이터의 유형의 여러 변수들을 조합해서 하나의 이름으로 정의해 사용하는 것

- 개요
  - 배열에서 개별적인 요소들의 위치는 첨자를 이용하여 지정
  - 배열은 변수명 뒤에 대괄호 []를 붙이고 그 안에 사용할 개수를 지정
  - 배열에서는 행 우선으로 데이터가 기억장소에 할당
  - C언어의 배열 위치는 0부터 시작
  - C언어에서 배열 위치를 나타내는 첨자 없이 배열 이름을 사용하면 배열의 첫 번째 요소의 주소를 지정하는 것과 같음

- 1차원 배열
  - 일직선상의 개념으로 조합한 배열

- 2차원 배열
  - 행과 열로 조합한 배열

- 배열으 ㅣ초기화
  - 배열 선언 시 초기값 지정 가능
  - 배열 선언 시 배열의 크기를 생략하면 반드시 초기값을 지정하여야 해당 개수 만큼의 배열이 선언
  - 배열의 초기값을 '숫자,'로 지정하면 배열의 첫 번째 요소에는 지정한 숫자, 나머지 요소에는 0이 입력

- 배열 형태의 문자열 변수
  - C언어에서 큰따옴표(" ")로 묶인 글자는 글자 수에 관계없이 문자열로 처리
  - C언어에는 문자열을 저장하는 자료형이 없어 배열 또는 포인터를 이용하여 처리
    - `char 배열이름[크기] = "문자열"`
  - 배열에 문자열을 저장하면 문자열의 끝을 알리기 위한 널 문자('\0')가 문자열 끝에 자동 삽입
    - 따라서 널 문자까지 고려하여 배열 크기를 지정해야 함
    - `char a[5] = "love" [l],[o],[v],[e],[\0]`
  - 배열에 문자열을 저장할 때는 배열 선언 시 초기값으로 지정하고, 이미 선언된 배열에는 문자열을 저장할 수 없음

<br>

### 포인터 A
> 변수의 주소이며, C언어에서는 주소를 제어할 수 있는 기능

- 개요
  - C언어에서 변수의 주소를 저장할 때 사용하는 변수를 포인터 변수라고 함
  - 포인터 변수를 선언할 때는 자료형을 먼저 쓰고, 변수명 앞에 간접 연산자 *를 붙임(`int *a;`)
  - 포인터 변수에 주소를 저장하기 위해 변수의 주소를 알아낼 때는 변수 앞에 번지 연산자 &를 붙임(`a = &b;`)
  - 실행문에서 포인터 변수에 간접 연산자(*)를 붙이면 해당 포인터 변수가 가리키는 곳의 값을 말함(`c = *a;`)
  - 필요에 의해 동적으로 할당되는 메모리 영역인 힙 영역에 접근하는 동적 변수
  - 용도
    - 연결된 자료 구조를 구성하기 위해 사용
    - 동적으로 할당된 자료 구조를 지정하기 위해 사용
    - 배열을 인수로 전달하기 위해 사용
    - 문자열을 표현하기 위해 사용
    - 커다란 배열에서 요소를 효율적으로 저장하기 위해 사용
    - 메모리에 직접 접근하기 위해 사용

- 포인터와 배열 : 배열을 포인터 변수에 저장한 후 포인터를 이용해 배열의 요소에 접근할 수 있음
  - 배열 위치를 나타내는 첨자를 생략하고 배열의 대표명만 지정하면 배열의 첫번째 요소 주소를 지정하는 것과 같음
  - &연산자를 사용
  - 배열 a에 대한 표기 방법
    - 배열 : a[0], a[1], a[2], a[3], a[4]
    - 포인터 : *(a+0), *(a+1), *(a+2), *(a+3), *(a+4)

<br>

### 사용자 정의 함수 A
> 사용자가 필요한 기능을 취향대로 만들어 사용할 수 있는 함수
> - 프로그램 구조가 간단해지고 이해하기 쉬워짐
> - 동일한 코드를 반복 입력하는 수고를 줄일 수 있음

<br>

### Java의 클래스와 메소드 A
> 클래스 : 객체 생성을 위한 필드(속성)과 메소드(함수)를 정의하는 설계도

- 클래스를 만들어 사용하는 순서
  - 클래스를 명명하고, 필드와 메소드를 정의
  - 클래스를 이용해 명령어 new를 사용하여 객체를 생성
  - 생서된 객체로 프로그래밍 진행

<br>

### Python의 기초 A
- 기본 문법
  - 변수의 자료형에 대한 선언이 없음
  - 세미콜론(;)을 사용할 필요가 없음
  - 변수에 연속하여 값을 저장하는 것이 가능
  - 코드 블록은 콜론(:)과 여백으로 구분
    - 여백은 일반적으로 4칸 또는 한 개의 탭만큼 띄워야 함
    - 같은 수준의 코드들은 반드시 동일한 여백을 가져야 함

- Python의 데이터 입출력 함수
  - input() 함수
    - 키보드로 입력받아 변수에 저장하는 함수
    - 입력되는 값은 문자열로 취급되어 저장

      ```py
      # 형식 1
      변수 = input(출력문자)

      # 형식 2
      변수1, 변수2 = input(출력문자).split(분리문자)
      ```
    - map() 함수 *( map(자료형, input().split()) )*
      - input().split()을 통해 입력받은 2개 이상의 값을 원하는 자료형으로 변환할 때 사용

  - print() 함수

    ```py
    # 형식 1
    print(출력값1, 출력값2, ..., sep = 분리문자, end = 종료문자)
  
    # 형식 2
    print(서식 문자열 % (출력값1, 출력값2, ...))
    ```

- Python의 문자열
  - 작은따옴표(' '), 큰따옴표(" "), 3개의 작은 따옴표(''' '''), 3개의 큰따옴표(""" """)로 묶어 표현
  - char 자료형이 없으므로 작은따옴표와 큰따옴표를 자유롭게 사용 가능
  - 3개의 따옴표를 사용하면 문자열 내에서 작은따옴표와 큰따옴표를 자유롭게 문자로 사용할 수 있음
  - 제어문자(커서의 이동이나 탭, 줄 나눔 등을 표현하는 문자) 사용 가능
  - 주요 메소드

    |형식|내용|
    |---|---|
    |upper()|대문자로 변경|
    |lower()|소문자로 변경|
    |capitalize()|문자열 첫 글자는 대문자, 나머지는 소문자로 변경|
    |title()|각 단어의 첫 글자만 대문자로 변경|
    |replace(값1, 값2)|문자열에서 값1을 찾아 값2로 교체|
    |split(값)|값을 기준으로 문자열을 분리하여 리스트로 반환<br>값을 생략하면 공백으로 문자열 분리|
    |count(값)|문자열에서 값의 개수를 반환|
    |find(값)|문자열에서 처음 검색되는 값의 위치를 반환<br>찾지 못하면 -1을 반환|
    |index(값)|문자열에서 처음 검색되는 값의 위치를 반환<br>찾지 못하면 오류 발생|

- 리스트(List)
  - Python은 배열(Array)을 제공하지 않음
  - 리스트를 선언할 때 크기를 적지 않음
  - 하나의 리스트에 정수, 실수, 문자열 등 다양한 자료형을 섞어 저장할 수 있음
  - 1차원 리스트

    ```py
    # 형식 1
    리스트명 = [ 값1, 값2, ... ]
    # 형식 2
    리스트명 = list([ 값1, 값2, ... ])

    # 리스트의 마지막에 값 추가 : append() 메소드
    a.append('B class')
    # 리스트의 중간에 값을 삽입 : insert() 메소드
    a.insert(1, 'Brown')
    # 리스트의 위치를 기준으로 요소를 삭제할 때 : del 메소드
    del a[3]
    # 값을 기준으로 요소를 삭제할 때 : remove() 메소드
    a.remove('mike')
    ```

  - 2차원 리스트 : 리스트에 리스트를 저장하는 방식

    ```py
    # 형식 1
    리스트명 = [
      [ 값1, 값2, 값3 ],
      [ 값4, 값5, 값6 ]
    ]
    # 형식 2
    리스트A = [ 값1, 값2, 값3 ]
    리스트B = [ 값4, 값5, 값6 ]
    리스트명 = [ 리스트A, 리스트B ]
    ```

    - 리스트 관련 주요 메소드

      |형식|내용|
      |---|---|
      |pop(위치)|리스트의 위치에 있는 값을 출력하고 해당 요소 삭제|
      |index(값)|리스트에서 값이 저장된 요소의 위치를 반환|
      |count(값)|리스트에서 값이 저장되어 있는 요소들의 개수를 반환|
      |extend(리스트)|리스트의 끝에 새로운 리스트를 추가하여 확장|
      |reverse()|리스트의 순서를 역순으로 뒤집음|
      |sort()|리스트를 정렬하며, 오름차순이 기본값<br>reverse 속성을 이용하여 정렬 방식을 지정할 수 있음<br>`[ 2, 1, 3 ].sort(reverse = True)`|
      |copy()|리스트를 복사|

- Range
  - 연속된 숫자를 생성하는 것으로 리스트, 반복문 등에서 많이 사용

    ```py
    # 형식 1, 0에서 최종값 -1까지 연속된 숫자 생성
    range(최종값)
    # 형식 2, 초기값에서 최종값 -1까지 연속된 숫자 생성
    range(초기값, 최종값)
    # 형식 3, 초기값에서 최종값 -1까지 증가값만큼 연속된 숫자 생성
    # 증가값이 음수라면 초기값에서 최종값 +1까지 증가값만큼 감소하면서 생성
    range(초기값, 최종값, 증가값)
    ```

- 슬라이스(Slice)
  - 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라 반환하는 기능

    ```py
    # 형식 1, 초기위치에서 최종위치 -1까지의 요소들을 가져옴
    객체명[초기위치:최종위치]
    # 형식 2, 초기위치에서 최종위치 -1까지 증가값만큼 해당 위치의 요소들을 가져옴
    # 증가값이 음수라면 초기위치에서 최종위치 +1까지 증가값만큼 감소하면서 가져옴
    객체명[초기위치:최종위치:증가값]
    
    # 일부 인수를 생략하여 사용할 경우
    ## 객체의 모든 요소 반환
    객체명[:] 또는 객체명 [::]
    ## 객체의 초기위치에서 마지막 위치까지 요소들 반환
    객체명[초기위치:]
    ## 객체의 0번째 위치에서 최종위치 -1까지 요소들 반환
    객체명[:최종위치]
    ## 객체의 0번째 위치에서 마지막까지 증가값만큼 해당 위치의 요소들 반환
    객체명[::증가값]
    ```

<br>

### Python의 활용 A
- if문

  ```py
  # 형식 1, 조건이 참일 때만 실행
  if 조건:
    실행할 문장

  # 형식 2, 조건이 참일 때와 거짓일 때 실행
  if 조건:
    실행할 문장 1
  else:
    실행할 문장 2

  # 형식 3, 조건이 여러 개이고, 조건마다 실행할 문장이 다름
  if 조건 1:
    실행할 문장 1
  elif 조건 2:
    실행할 문장 2
  elif 조건 3:
    실행할 문장 3
  else:
    실행할 문장 4

  # 형식 4, if문 안에 if문이 포함
  if 조건 1:
    if 조건 2:
      실행할 문장 1
    else:
      실행할 문장 2
  else:
    실행할 문장 3
  ```

- for문

  ```py
  # 형식 1, range를 이용한 방식
  for 변수 in ragne(최종값):
    실행할 문장
  
  # 형식 2, 리스트(List)를 이용한 방식
  for 변수 in 리스트
    실행할 문장
  ```

- while문
  ```py
  while 조건:
    실행할 문장
  ```

- 클래스
  ```py
  # 정의 형식
  class 클래스명:
    실행할 문장
    def 메소드명(self, 인수):
      실행할 문장
      return 값

  # 객체의 선언 형식
  변수명 = 클래스명()
  ```

<br>

### 라이브러리 B
### 절차적 프로그래밍 언어 C
### 객체지향 프로그래밍 언어 C
### 스크립트 언어 C
### 선언형 언어 C
### 예외 처리 C

<hr>
<br>

## 요구사항 확인
### 현행 시스템 파악 C
### 개발 기술 환경 파악 C
### 요구사항 정의 B
### 요구사항 분석 기법 C
### 요구사항 확인 기법 C
### UML A
> 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어

- 개요
  - UML은 공통된 표현법을 사용해 개발할 대상물을 다이어그램으로 표현하는 도구
  - 객체 기술에 관한 국제표준화기구 OMG에서 표준으로 지정
  - 시스템의 구조를 표현하는 6개의 구조 다이어그램과 시스템의 동작을 표현하는 7개의 행위 다이어그램을 작성할 수 있음
  - UML의 구성요소로 사물, 관계, 다이어그램 등이 존재

- 사물
  - 다이어그램 안에서 관계가 형성될 수 있는 대상들

  |사물|내용|
  |---|---|
  |구조 사물|시스템의 개념적, 물리적 요소를 표현<br>클래스, 유스케이스, 컴포넌트, 노드|
  |행동 사물|시간과 공간에 따른 요소들의 행위를 표현<br>상호작용, 상태 머신|
  |그룹 사물|요소들을 그룹으로 묶어서 표현<br>패키지|
  |주해 사물|부가적인 설명이나 제약조건 등을 표현<br>노트|

- 관계
  - 사물과 사물 사이의 연관성을 표현하는 것으로 연관, 집합, 포함, 일반화, 의존, 실체화 관계 등이 존재
  - 연관 관계
    - 2개 이상의 사물이 서로 관련되어 있음을 표현
    - 사물 사이를 실선으로 연결하여 표현하고 방향성은 화살표로 표현
    - 연관에 참여하는 객체의 개수를 의미하는 다중도를 선 위에 표기
  - 집합 관계
    - 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현
    - 포함하는 쪽과 포함되는 쪽은 서로 독립적
    - 포함되는 쪽에서 포함하는 쪽으로 속이 빈 마름모를 연결하여 표현
  - 포함 관계
    - 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
    - 포함하는 쪽과 포함되는 쪽은 서로 독립될 수 없고 생명주기를 함께 함
    - 포함되는 쪽에서 포함하는 쪽으로 속이 채워진 마름모를 연결하여 표현
  - 일반화 관계
    - 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
  - 의존 관계
    - 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현
  - 실체화 관계
    - 사물이 할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현

- 다이어그램
  - 사물과 관계를 도형으로 표현
  - 시스템을 가시화한 뷰를 제공
  - 주로 정적 모델링에서는 구조적 다이어그램을, 동적 모델링에서는 행위 다이어그램을 사용
  - 구조적 다이어그램의 종류

    |종류|설명|
    |---|---|
    |클래스 다이어그램|클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현|
    |객체 다이어그램|클래스에 속한 사물, 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현|
    |컴포넌트 다이어그램|실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현|
    |배치 다이어그램|결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현|
    |복합체 구조 다이어그램|클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현|
    |패키지 다이어그램|유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현|

  - 행위 다이어그램의 종류

    |종류|설명|
    |---|---|
    |유스케이스 다이어그램|사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용|
    |시퀀스 다이어그램|상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현|
    |커뮤니케이션 다이어그램|시퀀스 다이어그램과 같으나 메시지 뿐만 아니라 객체들 간의 연관 관계까지 표현|
    |상태 다이어그램|하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현|
    |활동 구조 다이어그램|시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현|
    |상호작용 개요 다이어그램|상호작용 다이어그램 간의 제어 흐름을 표현|
    |타이밍 다이어그램|객체 상태 변화와 시간 제약을 명시적으로 표현|

<br>

### 유스케이스 다이어그램 A
> 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점(View)에서 표현한 것
> - 외부 요소와 시스템 간의 상호 작용을 확인할 수 있음
> - 요구사항을 분석하기 위한 도구로 사용
> - 시스템의 범위를 파악할 수 있음

- 기능 모델링의 개요
  - 사용자가 요구한 기능들이 어떻게 작동하는지를 설명하기 위해 구현될 모습을 그림으로 표현
  - 개발될 시스템의 전반적인 형태를 기능에 초점을 맞춰 표현
  - UML의 기능 모델링에는 유스케이스 다이어그램과 액티비티 다이어그램이 존재

- 유스케이스 다이어그램의 구성 요소
  - 시스템/시스템 범위
    - 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현
  - 액터
    - 시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미
    - 시스템에 대해 수행할 수 있는 역할을 의미하기도 함
    - 액터 이름이 구체적이면 안 됨(구체적이면 액터의 대상이 하나로 고정되기 때문)
    - 주액터와 부액터가 존재
      - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상. 사람에 해당되며 주로 시스템의 왼쪽에 배치
      - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템, 조직이나 기관에 해당되며 주로 시스템의 오른쪽에 배치, 시스템명을 사각형으로 묶은 후 상단에 `<<Actor>>`라고 표기
  - 유스케이스
    - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것
    - 타원으로 표현하며 타원 안쪽이나 아래쪽에 유스케이스 이름을 기술
  - 관계
    - 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며 3종류의 관계가 존재
    - 포함 관계
      - 두 개 이상의 유스케이스에 공통적으로 적용되는 기능을 별도로 분리하여 유스케이스를 만든 경우 원래의 유스케이스와 새롭게 분리된 유스케이스와의 관계를 포함 관계라고 함
      - 점선 화살표를 연결한 후 화살표 위에 `<<include>>`라고 표기
    - 확장 관계
      - 유스케이스가 특정 조건에 부합되어 유스케이스의 기능이 확장 될 때 원래의 유스케이스와 확장된 유스케이스와의 관계를 확장 관계라고 함
      - 점선 화살표를 연결한 후 화살표 위에 `<<extends>>`라고 표기
    - 일반화 관계
      - 유사한 액터나 유스케이스를 하나의 그룹으로 묶고 싶을 때 그보다 일반적인 액터나 유스케이스를 만들어 이들을 연결하여 표현하는 관계를 일반화 관계라고 함
      - 하위 액터나 유스케이스가 상위 액터나 유스케이승게 역할이나 기능을 상속받는 관계
      - 속이 빈 삼각형 화살표를 실선으로 연결

- 유스케이스 명세서(기술서)
  - 유스케이스 안에서의 액터와 시스템 간의 상호 작용 과정을 글로 자세히 표현한 것
  - 모든 유스케이스에 대해 개별적으로 작성해야 함
  - 사건의 흐름을 참고하여 활동 다이어그램을 작성

<br>

### 활동 다이어그램 B
### 클래스 다이어그램 A
> 시스템을 구성하는 클래스, 클래스의 특성인 속성과 오퍼레이션, 속성과 오퍼레이션에 대한 제약조건, 클래스 사이의 관계를 표현한 것
> - 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램
> - 시스템 구성 요소를 문서화하는 데 사용

- 정적 모델링의 개요
  - 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것
  - 시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점에서 표현
  - 객체들을 클래스로 추상화하여 표현
  - UML을 이용한 정적 모델링의 대표적인 것이 클래스 다이어그램임

- 클래스
  - 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현
  - 일반적으로 3개의 구획인 이름, 속성, 오퍼레이션을 표기
  - 속성과 오퍼레이션은 생략할 수 있으나 이름은 반드시 명시
    - 생략된 경우 구획선을 그리지 않음
  - 속성 : 클래스의 상태나 정보를 표현
    - 접근제어자 : 속성과 오퍼레이션을 어느 정도까지 클래스 외부에 노출시킬지를 제어
    - 속성명 : 속성의 이름으로, 사용자가 임의로 작성
    - 자료형 : UML에서 기본적으로 제공하는 자료형 또는 사용자가 필요에 의해 새롭게 정의한 자료형을 사용할 수 있음
    - 다중성 : 동일한 속성명으로 여러 개의 속성 값을 가질 수 있는 것으로, 배열과 같은 의미
    - 초기값 : 데이터를 입력하지 않았을 때 기본적으로 입력되는 값을 지정
  - 오퍼레이션 : 클래스가 수행할 수 있는 동작으로 함수라고도 함
    - 오퍼레이션명 : 사용자가 임의로 작성
    - 매개변수 : 해당 오퍼레이션 수행에 필요한 값을 전달하기 위해 사용
    - 반환자료형 : 오퍼레이션 수행 후에 반환되는 값에 대한 자료형으로 반환되는 값이 없으면 반환자료형을 void로 지정

- 제약조건
  - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 작성
  - 주석 도형 안에 제약조건을 작성한 후 제약조건이 적용될 속성이나 오퍼레이션을 점선으로 연결
  - 클래스 안에 제약조건을 작성할 때는 중괄호 {}를 이용

- 관계
  - 클래스와 클래스 사이의 연관성을 표현
  - 관계에 참여하는 객체의 수(다중도)를 연관 관계 선 위에 표기
  - 연관 관계
    - 두 클래스가 서로 연관 관계에 있을 때는 클래스 안에 연관된 클래스를 이용하여 객체 변수를 생성할 수 있음
  - 집합 관계
    - 두 클래스가 서로 집합 관계에 있을 때 집합 관계에 있는 클래스의 객체 변수를 매개변수로 사용할 수 있음
  - 포함 관계
    - 두 클래스가 서로 포함 관게에 있을 때는 포함 관계에 있는 클래스를 이용하여 생성된 객체 변수를 이용하여 새로운 객체 변수를 생성할 수 있음
  - 일반화 관계
    - 일반적인 개념을 상위(부모) 클래스, 구체적인 개념을 하위(자식) 클래스라고 부름
    - 두 클래스가 서로 일반화 관계에 있을 때 하위 클래스가 상위 클래스의 속성이나 메소드를 사용할 수 있음
  - 의존 관계
    - 두 클래스가 서로 의존 관계에 있을 때는 영향을 주는 클래스(이용자)의 특정 오퍼레이션(메소드)이 수행 될 때만 영향을 받는 클래스(제공자)가 사용

<br>

### 시퀀스 다이어그램 B
### 커뮤니케이션 다이어그램 B
### 상태 다이어그램 B

<hr>
<br>

## 데이터 입출력 구현
### 데이터 모델의 개념 B
### 이상/함수적 종속/정규화 A
### 논리 데이터 모델의 물리 데이터 모델로 변환 A
### 반정규화 B
### 인덱스 설계 A
### 뷰 설계 A
### 클러스터 설계 A
### 파티션 설계 A
### 데이터베이스 용량 설계 C

4. 통합 구현
### 연계 요구사항 분석 C
### 연계 데이터 식별 및 표준화 C
### 연계 메커니즘 정의 B
### 연계 장애 및 오류처리 구현 C
### 연계 데이터 보안 적용 C
### 연계 모듈 구현 환경 C
### XML B
### 연계 테스트 C

5. 서버 프로그램 구현
### 개발 환경 구축 B
### 모듈 A
### 공통 모듈 C
### DBMS 접속 B
### 서버 개발 C
### 서버 개발 과정 A
### 배치 프로그램 B

<hr>
<br>

## 화면 설계
### 사용자 인터페이스 A
> 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어
   
- 사용자 인터페이스의 세 가지 분야
  - 정보 제공과 전달을 위한 물리적 제어
  - 콘텐츠의 상세적인 표현과 전체적인 구성
  - 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능

- 사용자 인터페이스의 구분
  - CLI(Command Line Interface) : 텍스트 환경의 인터페이스
  - GUI(Graphical User Interface) : 그래픽 환경의 인터페이스   
  - NUI(Natural User Interface) : 사용자의 말, 행동으로 조작하는 인터페이스

- 사용자 인터페이스의 기본 원칙
  - 직관성 : 누구나 쉽게 사용할 수 있는가?
  - 유효성 : 사용자의 목적을 정확히 이해했는가?
  - 학습성 : 누구나 쉽게 배울 수 있는가?
  - 유연성 : 사용자의 실수가 최소화되고 요구사항을 최대한 수용하는가?

- 사용자 인터페이스의 설계 지침
  - 사용자 중심
  - 일관성
  - 단순성
  - 결과 예측 가능
  - 가시성
  - 표준화
  - 접근성
  - 명확성
  - 오류 발생 해결

- UI 설계 도구

  |도구|개요|
  |---|---|
  |와이어프레임(Wireframe)|기획 단계의 초기에 제작|
  |목업(Mockup)|실제 화면과 유사하게 만든 정적인 형태의 모형|
  |스토리보드(Story Board)|콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서|
  |프로토타입(Prototype)|실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형|
  |유스케이스(Use Case)|사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술|

<br>

### UI 표준 및 지침 B

<br>

### UI 요구사항 확인 B

<br>

### UI 프로토타입 제작 및 검토 A
> 사용자 요구사항을 기반으로 실제 동작하는 것처럼 만든 테스트가 가능한 동적인 형태의 모형
> - 최종적으로 구현할 화면의 주요 기능을 직접 실행해 볼 수 있도록 미리 만든 임시 화면

- 개요
  - 검증하기 위한 것으로 최대한 간단하게 만들어야 한다.
  - 핵심적인 기능만을 제공하나 필요한 기능은 반드시 포함되어야 한다.
  - 계속하여 개선하고 보완해야한다.
  - 실제 사용자를 대상으로 테스트하는 것이 좋다.

- 장점 및 단점
  - 사용자를 설득하고 이해시키기 쉽다.
  - 요구사항과 기능의 불일치 등을 줄여 개발 시간을 줄일 수 있다.
  - 사전에 오류를 발견하여 개선할 수 있다.
  - 반복적인 개선 및 보완 작업 때문에 작업 시간이 증가되거나 필요 이상의 자원이 소모된다.
  - 누락시키는 프로토타이핑이 발생하여 중요한 작업이 생략될 수 있다.

- 프로토타이핑의 종류

  |프로토타이핑|개요|
  |--------|----|
  |페이퍼 프로토타입(Paper Prototype)|손으로 직접 작성하는 방법|
  |디지털 프로토타입(Digital Prototype)|프로그램을 사용하여 작성하는 방법|

- UI 프로토타입 제작 단계

  |단계|개요|
  |---|---|
  |1단계|요구사항 분석|
  |2단계|프로토타입 개발|
  |3단계|사용자의 확인|
  |4단계|개발에 대한 수정|

<br>

### UI 흐름 설계 B

<br>

### UI 상세 설계 B

<hr>
<br>

## 에플리케이션 테스트 관리
### 애플리케이션 테스트 B

<br>

### 애플리케이션 테스트의 분류 B

<br>

### 테스트 기법에 따른 애플리케이션 테스트 A
> 화이트박스 테스트 : 내부의 논리적인 경로를 테스트
> - 선택, 반복 등의 분기점 부분들을 수행함으로써 논리적인 경로를 제어

- 화이트박스 테스트의 종류

  |테스트 종류|개요|
  |--------|---|
  |기초 경로 검사|대표적인 화이트 테스트 기법|
  |제어 구조 검사|조건 검사, 루프 검사, 데이터 흐름 검사|

  - 조건 검사(Contition Testing) : 논리적 조건 테스트
  - 루프 검사(Loop Testing) : 반복 구조 테스트
  - 데이터 흐름 검사(Data Flow Testing) : 변수 등의 데이터 제어 테스트

- 화이트박스 테스트의 검증 기준
  - 문장 검증 기준 : 소스 코드의 모든 구문이 한 번 이상 수행되는 테스트 케이스
  - 분기 검증 기준 : 소스 코드의 모든 조건문이 한 번 이상 수행되는 테스트 케이스
  - 조건 검증 기준 : 소스 코드의 모든 조건문이 true 와 false 일 때 한 번 이상 수행되는 테스트 케이스
  - 분기/조건 기준 : 소스 코드의 모든 조건문과 각 조건문의 조건식 결과가 true 와 false 일 때 한 번 이상 수행되는 테스트 케이스

- 검증 기준의 종류
  - 기능 기반 커버리지 : 실제 테스트가 수행된 기능의 수 / 전체 기능의 수
  - 라인 커버리지 : 테스트 시나리오가 수행한 소스 코드의 라인 수 / 전체 소스 코드의 라인 수
  - 코드 커버리지 : 소스 코드의 구문, 분기, 조건 등의 구조 코드 자체가 얼마나 테스트 되었는지 측정한 수

> 블랙박스 테스트 : 각 기능이 완전히 작동되는 것을 입증하는 기능 테스트
> - 사용자의 요구사항 명세를 보면서 테스트하며 주로 구현된 기능을 확인

- 블랙박스 테스트의 종류
  - 동치 분할 검사 : 입력 자료에 초점을 두는 테스트 케이스
  - 경계값 분석 : 입력 조건의 경계값으로 확인하는 테스트 케이스
  - 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력을 확인하는 테스트 케이스
  - 오류 예측 검사 : 과거의 경험이나 확인자의 감각을 초점에 두는 테스트 케이스
  - 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 나오는지 확인하는 테스트 케이스

<br>

### 개발 단계에 따른 애플리케이션 테스트 A
> 소프트웨어 개발 단계에서부터 테스트를 수행
> - 소프트웨어에 포함된 코드 상의 오류 및 요구 분석의 오류, 설계 인터페이스 오류 등도 발견
> - V-모델 : 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것

- 애플리케이션 테스트의 순서
  - 단위 테스트 : 모듈에 대한 테스트
  - 통합 테스트 : 모듈을 결합하여 시스템으로 완성시키는 과정에서의 테스트
  - 시스템 테스트 : 시스템에서 정상적으로 수행되는지를 확인하기 위한 테스트
  - 인수 테스트 : 사용자에게 인도하기 전에 수행하는 테스트

- 단위 테스트(Unit Test)
  - 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
  - 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행

    |테스트 방법|테스트 내용|테스트 목적|
    |--------|--------|---------|
    |구조 기반 테스트|화이트박스 테스트 시행|제어 흐름, 조건 결정|
    |명세 기반 테스트|블랙박스 테스트 시행|동등 분할, 경계 값 분석|

- 통합 테스트(Intergration Test)
  - 단위 테스트과 완료된 모듈들을 결합하여 시행하는 테스트
  - 상호 작용 오류를 검사

- 시스템 테스트(System Test)
  - 개발된 소프트웨어가 완벽하게 수행되는가를 점검하는 테스트

    |테스트 방법|테스트 내용|
    |--------|--------|
    |기능적 요구사항|블랙박스 테스트 시행|
    |비기능적 요구사항|화이트박스 테스트 시행|

- 인수 테스트(Acceptance Test)
  - 사용자의 요구사항을 충족하는지에 중점을 두고 테스트
  - 사용자가 직접 테스트

    |테스트 종류|테스트 내용|
    |--------|--------|
    |사용자 인수 테스트|사용자가 시스템 사용의 적절성 여부 테스트|
    |운영자 인수 테스트|시스템 관리자가 시스템 인수 시 수행하는 테스트|
    |계약 인수 테스트|계약상의 인수/검수 조건을 준수하는지 테스트|
    |규정 인수 테스트|정부 지침, 법규, 규정 등에 맞게 개발되었는지 테스트|
    |알파 테스트|사용자와 개발자가 함께 확인하며 기록하는 테스트|
    |베타 테스트|실업무를 통해 사용자가 직접 테스트|

<br>

### 통합 테스트 A
> 단위테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법

|통합 테스트 방법|개요|
|------------|---|
|비점진적 통합 방식|규모가 작은 소프트웨어 유리하며 단시간 내에 테스트가 가능하며 빅뱅 통합 테스트가 존재|
|점진적 통합 방식|모듈 단위로 단계적 통합을 거쳐 테스트하는 방법으로 하향식, 상향식, 혼합식 통합 방식이 존재|

- 하향식 통합 테스트
  - 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트
  - 테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있음
  - 깊이 우선 통합법 : 주요 제어 모듈을 중심으로 해당 모듈에 종속된 모든 모듈을 통합
  - 넓이 우선 통합법 : 구조의 수평을 중심으로 해당하는 모듈을 통합
  - 테스트 스텁 : 일시적으로 필요한 조건만을 가지고 있는 시험용 모듈
  - 회귀 테스트 : 이미 테스트된 프로그램의 테스팅을 반복

- 상향식 통합 테스트
  - 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트
  - 데이터의 입출력을 확인하기 위해 드라이버를 작성

- 혼합식 통합 테스트
  - 하위 수준에서 상향식 통합, 상위 수준에서 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식
  - 샌드위치식 통합 테스트 방법이라고도 함

- 회귀 테스팅
  - 이미 테스트된 프로그램의 테스팅을 반복
  - 시간과 비용이 많이 필요
  - 선정 방법
    - 모든 애플리케이션의 기능을 수행할 수 있는 대표적인 테스트 케이스를 선정
    - 파급 효과가 높은 부분이 포함된 테스트 케이스를 선정
    - 실제 수정이 발생한 모듈 또는 컴포넌트에서 시행하는 테스트 케이스를 선정

<br>

### 애플리케이션 테스트 프로세스 B

<br>

### 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 B

<br>

### 테스트 자동화 도구 B

<br>

### 결함 관리 B

<br>

### 애플리케이션 성능 분석 C

<br>

### 애플리케이션 성능 개선 C

<hr>
<br>

## SQL응용
### SQL : DDL C
### SQL : DML C
### SQL : DCL B
### DML : SELECT 1 A
> 일반형식, 기본 검색, 조건 지정 검색, 정렬 검색, 하위 질의, 복수 테이블 질의

- DISTINCT : 중복된 튜플 중 첫 번째 한 개만 검색
- DISTINCTROW : 중복된 튜플을 제거하고 한 개만 검색하나 선택된 속성의 값이 아니라 튜플 전체를 대상으로 함
- ORDER BY 절 : ASC 는 오름차순, DESC 는 내림차순, 생략하면 오름차순으로 지정
- 날짜 데이터는 숫자로 취급하지만 ' ' 또는 # #으로 묶어줌

<br>

### DML : SELECT 2 A
- WINDOW 함수 : GROUP BY 절을 이용하지 않고 속성의 값을 집계할 함수를 기술
  - PARTITION BY : WINDOW 함수가 적용될 범위로 사용할 속성을 지정

|그룹함수|개요|
|-----|----|
|COUNT(속성명)|그룹별 튜플 수를 구함|
|SUM(속성명)|그룹별 합계를 구함|
|AVG(속성명)|그룹별 평균을 구함|
|MAX(속성명)|그룹별 최대값을 구함|
|MIN(속성명)|그룹별 최소값을 구함|
|STDDEV(속성명)|그룹별 표준편차를 구함|
|VARIANCE(속성명)|그룹별 분산을 구함|
|ROLLUP(속성명)|인수로 주어진 속성을 대상으로 그룹별 소계를 구함|
|CUBE(속성명)|인수로 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구함|

<br>

### 프로시저 A
> 일종의 트랜잭션 언어로 데이터베이스에 저장되어 수행되므로 스토어드 프로시저라고도 불림
> - 일일 마감 작업, 일괄 작업 등에 주로 사용

<br>

### 트리거 B
### 사용자 정의 함수 B
### 제어문 A
> 절차형 SQL의 서술된 순서에 따라 진행되는 특징을 변경하기 위해 사용

<br>

### 커서 A
> 메모리 공간을 가리키는 포인터
> - 자동으로 생성되어 사용되는 묵시적 커서와 사용자가 직접 정의해서 사용하는 명시적 커서가 존재

- 개요
  - 커서의 수행은 열기, 패치, 닫기의 세 단계로 진행
    - 묵시적 커서는 각 단계가 자동으로 수행되나 명시적 커서는 직접 구현하여야 함

<hr>
<br>

## 소프트웨어 개발 보안 구축
### 소프트웨어 개발 보안 A
> 데이터의 기밀성, 무결성, 가용성을 유지하는 것이 목표

- 안전한 소프트웨어 개발을 위한 수행 작업
  - 프로젝트 참여자들의 역할과 책임을 명확히 정의하고 충분한 보안 교육을 실시
  - 소프트웨어 개발 생명주기(SDLC)의 각 단계마다 보안 활동을 수행
  - 표준을 확립
  - 재사용이 가능한 보안 모듈을 작성
  - 보안 통제의 효과성 검증을 실시

- 소프트웨어 개발 보안 관련 기관
  - 행정안전부
    - 개발 보안 정책 총괄
    - 관련 법규, 지침, 제도 정비
    - 보안 약점을 진단하는 사람의 양성 및 관련 업무 수행
  - 한국인터넷진흥원
    - 정책 및 가이드 개발
    - 기술 지원
    - 교육과정 및 자격제도 운영
  - 발주기관
    - 계획 수립
    - 사업자 및 감리법인 선정
    - 준수 여부 점검
  - 사업자
    - 기술 수준 및 적용 계획 명시
    - 인력을 대상으로 교육 실시
    - 가이드를 참조하여 개발
    - 보안 약점을 진단하고 제거
    - 시정 요구사항을 이행
  - 감리법인
    - 감리 계획을 수립하고 협의
    - 제거 여부 및 조치 결과를 확인

- 소프트웨어 개발 보안 활동 관련 법령
  - 개인정보 보호법
    - 개인의 자유와 권리를 보호
  - 정보통신망 이용촉진 및 정보보호 등에 관한 법률
    - 정보통신 서비스를 이용하는 이용자들의 개인정보를 보호
  - 신용정보의 이용 및 보호에 관한 법률
    - 정보의 오남용 방지
  - 위치정보의 보호 및 이용 등에 관한 법률
    - 정보의 유출이나 오남용 방지
  - 표준 개인정보 보호 지침
    - 세부사항 규정
  - 개인정보의 안전성 확보 조치 기준
    - 최소한의 기준을 규정
  - 개인정보 영향평가에 관한 고시
    - 평가기관의 지정, 영향평가의 절차 등에 관한 세부기준을 규정

- 소프트웨어 개발 보안 활동 관련 기타 규정
  - RFID 프라이버시 보호 가이드라인
  - 위치정보의 보호 및 이용 등에 관한 법률
  - 위치정보의 관리적, 기술적 보호조치 권고 해설서
  - 바이오정보 보호 가이드라인
  - 뉴미디어 서비스 개인정보 보호 가이드라인

<br>

### Secure SDLC A
> SDLC에 보안 강화를 위한 프로세스를 포함한 것을 의미
> - Secure Software 사의 CLASP, Microsoft 사의 SDL 이 존재

- 보안요소
  - 기밀성 : 인가된 사용자에게만 접근 허용
  - 무결성 : 인가된 사용자만 수정
  - 가용성 : 합법적인 사용자인지를 확인하는 모든 행위
  - 부인 방지 : 송수신 증거를 제공

- 설계 단계에서의 보안 활동
  - 네트워크 : 네트워크를 분리하거나 방화벽을 설치
  - 서버 : 보안이 뛰어난 운영체제를 사용하고 외부접속에 대한 접근통제 실시
  - 물리적 보안 : 출입통제, 개발 공간 제한, 감시설비 설치
  - 개발 프로그램 : 허가되지 않은 프로그램을 통제하고 지속적인 데이터 무결성 검사 실시

- 구현 단계에서의 보안 활동
 - 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수
 - 시큐어 코딩 : 보안 요소들을 고려하며 코딩

- 테스트 단계에서의 보안 활동
  - 정적 분석 도구, 동적 분석 도구 또는 모의 침투테스트를 통해 설계 단계에서 식별된 위협들의 해결여부 검증

<br>

### 세션 통제 B
### 입력 데이터 검증 및 표현 B
### 보안 기능 B
### 시간 및 상태 C
### 에러처리 B
### 코드 오류 B
### 캡슐화 C
### API 오용 C
### 암호 알고리즘 A
> 해시(Hash)를 사용하는 단방향 암호화 방식과 개인키 및 공개키로 분류되는 양방향 암호화 방식이 존재

- 개인키 암호화 기법
  - 동일한 키로 데이터를 암호화하고 복호화
  - 대칭 암호 기법 또는 단일키 암호화 기법이라고도 함
  - 한 번에 하나의 데이터 블록을 암호화 하는 블록 암호화 방식과 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화 하는 스트림 암호화 방식으로 분류
  - 종류
    - 블록 암호화 방식 : DES, SEED, AES, ARIA
    - 스트림 암호화 방식 : LFSR, RC4
  - 장점 : 암/복호화 속도가 빠르고 알고리즘이 단순하며 공개키 암호 기법보다 파일 크기가 작음
  - 단점 : 사용자가 증가하면 관리해야 할 키의 수가 상대적으로 많아짐

- 공개키 암호화 기법
  - 암호화할 때 사용하는 공개키는 데이터베이스 사용자에게 공개하고, 복호화할 때 사용하는 비밀키는 관리자가 비밀리에 관리
  - 비대칭 암호 기법이라고도 하며 RSA 기법이 대표적
  - 장점 : 키의 분배가 용이하고 관리애햐 할 키의 개수가 적음
  - 단점 : 암/복호화 속도가 느리고 알고리즘이 복잡하며 개인키 암호화 기법보다 파일 크기가 큼

- 공개키 기반 구조
  - X.509 방식 : 인증기관에서 발생하는 인증서를 기반으로 상호 인증을 제공
  - 비X.509 방식 : 국가별, 지역별로 맞게 보완하여 개발

- 양방향 알고리즘 종류
  - SEED
    - 한국인터넷진흥원에서 개발한 블록 암호화 알고리즘
    - 블록 크기는 128비트, 키 길이에 따라 128, 256으로 분리
  - ARIA
    - 국가정보원과 산학연합회가 개발한 블록 암호화 알고리즘
    - 학계, 연구기관, 정부의 영문 앞 글자로 구성
    - 블록 크기는 128비트, 키 길이에 따라 128, 192, 256으로 분리
  - DES
    - 미국 NBS 에서 발표한 개인키 암호화 알고리즘
    - DES를 3번 적용하여 보안을 강화한 3DES가 있음
    - 블록 크기는 64비트, 키 길이는 56비트
  - AES
    - 미국 표준 기술 연구소(NIST)에서 발표한 개인키 암호화 알고리즘
    - DES의 한계를 보완하기 위해 발표
    - 블록 크기는 128비트, 키 길이는 128, 192, 256으롷 분류
  - RSA
    - MIT에서 제안된 공개키 암호화 알고리즘
    - 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 작성
    - 공개키와 비밀키를 사용하며 메시지를 열고 잠그는 상수(Const)를 키로 사용

- 해시(Hash)
  - 임의의 길이를 가진 데이터를 고정된 길이의 값이나 키로 변환하는 알고리즘
  - 정보보호의 다양한 분야에서 활용
  - 종류
    - SHA 시리즈
    - MD5
    - N-NASH
    - SNEFRU

<br>

## 응용 SW 기초 기술 활용
### 운영체제의 개념 A
> 컴퓨터 시스템의 자원들을 효율적으로 관리
> - 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있는 환경을 제공하는 여러 프로그램의 모임
> - 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스

- 운영체제의 목적
  - 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축
  - 처리 능력 : 일정 시간 내에 시스템이 처리하는 일의 양
  - 반환 시간 : 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸리는 시간
  - 사용 가능도 : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
  - 신뢰도 : 시스템이 주어진 문제를 정확하게 해결하는 정도

- 운영체제의 기능
  - 프로세서, 기억장치, 입출력장치, 파일 및 정보 등의 자원을 관리
  - 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공
  - 사용자와 시스템 간의 편리한 인터페이스를 제공
  - 시스템의 각종 하드웨어와 네트워크를 관리
  - 데이터를 관리하고 데이터 및 자원의 공유 기능을 제공
  - 시스템의 오류를 검사하고 복구
  - 자원 보호 기능을 제공
  - 입출력에 대한 보조 기능을 제공
  - 가상 계산기 기능을 제공

- 운영체제의 주요 자원 관리
  - 기억장치 관리 : 프로세스에게 메모리 할당 및 회수 관리 담당
  - 프로세스 관리 : 프로세스 스케줄링 및 동기화 관리 담당
  - 주변장치 관리 : 입출력장치 스케줄링 및 전반적인 관리 담당
  - 파일 관리 : 파일의 생성과 삭제, 변경, 유지 등의 관리 담당

- 운영체제의 종류
  - 단일 작업 처리 시스템 : MS-DOS
  - 다중 작업 처리 시스템 : Windows, UNIX, LINUX, MacOS

<br>

### 운영체제의 종류 B
### 운영체제의 기본 명령어 B
### 기억장치 관리 C
### 프로세스 관리 C

<br>

### 데이터베이스 개념 A
> 특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

- 정의
  - 통합된 데이터 : 중복이 최소화된 데이터의 모임
  - 저장된 데이터 : 컴퓨터가 접근 가능한 저장 매체에 저장된 데이터
  - 운영 데이터 : 조직의 고유한 업무를 수행하는 데 없어서는 안 될 반드시 필요한 데이터
  - 공용 데이터 : 여러 응용 시스템들이 공동으로 소유 및 유지하는 데이터

- DBMS
  - 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템
  - 데이터베이스의 구성, 접근 방법, 유지관리에 대해 모든 책임을 짐
  - 필수 기능
    - 정의 기능 : 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 조건을 명시하는 기능
    - 조작 기능 : 데이터 조작을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이에 인터페이스 수단을 제공하는 기능
    - 제어 기능 : 데이터베이스를 접근하는 수정 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어하는 기능

- DBMS의 종류
  - 계층형
    - 트리 구조, 일 대 다 대응 관계만 존재
    - 종류 : IMS, System2000
  - 망형
    - 그래프 구조, 일 대 일, 일 대 다, 다 대 다 대응 관계 지원
    - 종류 : IDS, TOTAL, IDMS
  - 관계형
    - 2차원적인 표를 하나의 DB로 묶어서 테이블 내에 있는 속성들 간/테이블 간의 관계를 설정하여 이용
    - 종류 : Oracle, SQL Server, MySQL
  - 비관계형
    - 데이터 간의 관계를 정의하지 않고 비구조적인 데이터를 저장하기 위한 시스템
    - 빅데이터를 처리하기 위한 데이터베이스
    - 수평적 확장 및 분산 저장이 가능
    - 종류 : Key-Value DBMS, Document DBMS, Graph DBMS

- DBMS의 장단점
  - 장점
    - 데이터의 논리적, 물리적 독립성이 보장
    - 데이터의 중복을 피하여 기억공간이 절약
    - 저장된 자료를 공동으로 이용
    - 데이터의 일관성을 윺지
    - 데이터의 무결성을 유지
    - 보안을 유지
    - 데이터 표준화
    - 데이터 통합 관리
    - 최신 데이터 유지
    - 데이터의 실시간 처리 가능
  - 단점
    - 전문가 부족
    - 전산화 비용 증가
    - 집중적 액세스로 과부하 발생
    - 백업과 리커버리가 어려움
    - 시스템이 복잡

<br>

### ER모델 B
### 관계형 데이터 모델 A
> 데이터를 테이블 또는 릴레이션의 구조로 표현하는 논리적 데이터 모델

- 관계형 데이터 구조 : 릴레이션
  - 릴레이션 : 데이터를 원자 값으로 갖는 2차원의 테이블
  - 릴레이션의 구조 : 논리적 구조이므로 다양한 정렬 기준을 통해 릴레이션을 표현 가능
  - 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성
  - 열을 속성이라 하고 행을 튜플이라 함
  - 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자 값들의 집합을 도메인이라고 함

- 용어
  - 릴레이션 스키마
    - 릴레이션의 이름, 각 송성의 이름과 타입, 속성 값의 도메인을 정의하는 릴레이션 틀
    - 릴레이션 스킴 또는 릴레이션 내포라고도 부름
  - 릴레이션 인스턴스
    - 릴레이션에 들어 있는 튜플들의 집합
    - 릴레이션 또는 릴레이션 외연이라고도 부름
  - 애트리뷰트(컬럼)
    - 디그리 = 속성의 수 = 차수
  - 튜플(로우)
    - 카디널리티 = 튜플의 수 = 기수

- ER 모델을 관계형 데이터 모델로 변환
  - 개념적 데이터 모델인 ER모델을 논리적 모델인 릴레이션 스키마로 변환하는 것으로 매핑 룰이라고 함
  - ER 도형에서의 개체와 관계는 관계형 데이터 모델에서의 개체 릴레이션과 관계 릴레이션으로 변환하여 표현
  - 속성은 컬럼으로, 식별자는 기본키로, 릴레이션 간의 관계는 기본키와 이를 참조하는 외래키를 이용하여 표현

<br>

### 키의 개념 및 종류 B
### 무결성 A
> 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미
> - 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약

- 무결성의 종류
  - 개체 무결성
    - 기본키를 구성하는 어떤 속성도 Null 값이나 중복값을 가지지 못함
  - 도메인 무결성
    - 주어진 속성 값이 정의된 도메인에 속한 값이어야 함
  - 참조 무결성
    - 외래키 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 함
  - 사용자 정의 무결성
    - 속성 값들이 사용자가 정의한 제약조건에 만족해야 함
  - NULL 무결성
    - 릴레이션의 특정 속성 값이 Null이 될 수 없음
  - 고유 무결성
    - 각 튜플이 갖는 속성값들이 서로 달라야 함
  - 키 무결성
    - 하나의 릴레이션에는 적어도 하나의 키가 존재해야 함
  - 관계 무결성
    - 튜플들 사이의 관계에 대한 적절성 여부를 지정

<br>

### 네트워크/인터넷 A
> 두 대 이상의 컴퓨터를 전화선이나 케이블 등으로 연결하여 자원을 공유하는 것
> - 지리적 범위에 따라 LAN과 WAN으로 분류

- 네트워크 통신망의 종류
  - 근거리 통신망(LAN)
    - 비교적 가까운 거리에 있는 자원을 연결하여 구성
    - 주로 자원 공유를 목적
    - 사이트 간의 거리가 짧아 데이터의 전송 속도가 빠르고, 에러 발생율이 낮음
    - 주로 버스형, 링형 구조를 사용
  - 광대역 통신망(WAN)
    - 멀리 떨어진 사이트들을 연결하여 구성
    - 사이트 간의 거리가 멀어 데이터의 전송 속도가 느리고, 에러 발생율이 높음
    - 일정한 지역에 있는 사이트들을 근거리 통신망으로 연결하고 각 근거리 통신망을 확장하는 방식

- 인터넷의 개요
  - 미 국방성의 ARPANET에서 시작
  - 유닉스 운영체제 기반
  - 인터넷에 연결된 모든 컴퓨터는 고유한 IP를 보유
  - 컴퓨터 또는 네트워크를 연결하기 위해 브릿지, 라우터, 게이트웨이가 사용
  - 보통 인터넷의 주가 되는 기간망을 백본이라 칭함

- IP 주소
  - 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소

- IPv6
  - IPv4의 주솧 부족 문제를 해결하기 위해 개발
  - IPv4에 비해 자료 전송 속도가 빠름
  - IPv4와 호환성이 뛰어남
  - 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결
  - 주소의 확장성, 융통성, 연동성이 뛰어남
  - 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원
  - 트래픽 클래스, 플로우 레이블을 이용하여 등급별, 서비스별로 패킷을 구분할 수 있어 품질 보장이 용이
  - 구성
    - 유니캐스트 : 단일 송신자-단일 수신자
    - 멀티캐스트 : 단일 송신자-다중 수신자
    - 애니캐스트 : 단일 송신자-가장 가까이 있는 단일 수신자

- 도메인 네임
  - 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현
  - 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관 종류, 소속 국가명 순
    - 왼쪽에서 오른쪽으로 갈 수록 상위 도메인
  - 문자로 된 도메인 네임을 컴퓨터가 이해하기 위해 IP 주소로 변환하는 역할을 하는 시스템이 DNS
    - 이런 역할 하는 서버를 DNS 서버라고 부름

<br>

### OSI 참조 모델 A
> 다른 시스템 간의 원활한 통신을 위해 ISO에서 제안한 통신 규약
> - 1~3계층을 하위 계층, 4~7계층을 상위 계층이라고 함
> - 물-데-네-전-세-표-응

- OSI 참조 모델의 목적
  - 서로 다른 시스템 간을 상호 접속하기 위한 개념
  - OSI 규격을 개발하기 위한 범위를 지정
  - 관련 규정의 적합성을 조절하기 위한 공통적 기반 제공

- OSI 참조 모델에서의 데이터 단위
  - 프로토콜 데이터 단위 : 동일 계층 간에 교환되는 정보의 단위
    - 물리 계층 : 비트
    - 데이터 링크 계층 : 프레임
    - 네트워크 계층 : 패킷
    - 전송 계층 : 세그먼트
    - 세션, 표현, 응용 계층 : 메시지
  - 서비스 데이터 단위 : 서비스 접근접(SAP)을 통해 상/하위 계층끼리 주고 받는 정보의 단위

- 물리 계층
  - 두 장치 간의 실제 접속과 절단 등의 특성에 대한 규칙 정의
  - 물리적 전송 매체와 전송 신호 방식을 정의
  - 관련 장비 : 리피터, 허브

- 데이터 링크 계층
  - 신뢰성 있고 효율적인 정보 전송이 가능하게 함
  - 송신-수신 측의 속도 차이를 해결하기 위한 흐름 제어
  - 프레임의 동기화
  - 유르 제어
  - 순서 제어
  - 관련 장비 : 랜카드, 브릿지, 스위치

- 네트워크 계층
  - 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능
  - 네트워크 연결을 설정, 유지 해제
  - 관련 장비 : 라우터

- 전송 계층
  - 논리적 안정과 균일한 데이터 전송 서비스를 제공
  - 하위 3계층과 상위 3계층의 인터페이스 담당
  - TCP, UDP 표준 존재
  - 관련 장비 : 게이트웨이

- 세션 계층
  - 대화(회화) 구성 및 동기 제어, 데이터 교환 관리
  - 정보의 수신 상태를 체크하고 이 체크점을 동기점이라고 함
  - 동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로 소동기점과 대동기점이 있음

- 표현 계층
  - 통신에 적당한 데이터로 변환
  - 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층

- 응용 계층
  - 사용자가 OSI 환경에 접근할 수 있도록 서비스를 제공

<br>

### 네트워크 관련 장비 B
### TCP/IP A
> 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜
> - UNIX의 기본 프로토콜로 사용되었으며 현재는 인터넷 범용 프로토콜임

- 개요
  - TCP
    - 연결형 서비스 제공
    - 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능 제공
    - 스트림 전송 기능 제공
  - IP
    - 데이터그램을 기반으로 하는 비연결형 서비스 제공
    - 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공

- 프로토콜의 특징
  - 단편화, 재조립, 캡슐화, 연결 제어, 오류 제어, 동기화, 다중화, 주소 지정

- TCP/IP의 구조

  |OSI|TCP/IP|기능|
  |---|------|---|
  |응용 계층/표현 계층/세션 계층|응용 계층|응용 프로그램 간의 데이터 송수신 제공|
  |전송 계층|전송 계층|호스트들 간의 신뢰성 있는 통신 제공|
  |네트워크 계층|인터넷 계층|데이터 전송을 위한 주소 지정, 경로 설정 제공|
  |데이터 링크 계층, 물리 계층|네트워크 엑세스 계층|실제 데이터(프레임)를 송수신하는 역할|

- 응용 계층의 주요 프로토콜
  - FTP
    - 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜
  - SMTP
    - 전자 우편을 교환하는 서비스
  - TELNET
    - 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
  - HTTP
    - 월드와이드웹에서 HTML 문서ㅗ를 송수신 하기 위한 표준 프로토콜
  - SNMP
    - TCP/IP의 네트워크 관리 프로토콜
  - DNS
    - 도메인 네임을 IP 주소로 매핑하는 시스템

- 전송 계층의 주요 프로토콜
  - TCP
    - 양방향 연결형 서비스 제공
    - 가상 회선 연결 형태의 서비스 제공
    - 스트림 위주의 전달(패킷 단위)
    - 신뢰성 있는 경로를 확립하고 메시지 전송을 감독
    - 투명성이 보이는 통신 제공
  - UDP
    - 비연결형 서비스 제공
    - TCP보다 상대적으로 단순해 오버헤드가 적음
    - 고속의 안정성 있는 전송 매체를 사용하여 빠른 속도가 필요하거나, 동시에 여러 사용자에게 데이터를 전송하거나, 정기적으로 반복해야할 경우 사용
    - 실시간 전송에 유리하며 신뢰성보다 속도가 중요시되는 네트워크에서 사용
  - RTCP
    - 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
    - 데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공

- 인터넷 계층의 주요 프로토콜
  - IP
    - 주소를 지정하고 경로를 설정하는 기능
    - 데이터그램 방식을 사용
  - ICMP
    - 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지 관리 역할
  - IGMP
    - 멀티캐스트 그룹 유지를 위해 사용
  - ARP
    - 호스트의 IP 주소를 물리적 주소(MAC Address)로 변환
  - RARP
    - 물리적 주소를 IP 주소로 변환

- 네트워크 액세스 계층의 주요 프로토콜
  - Ethernet : CSMA/CD 방식의 LAN
  - IEEE 802 : LAN을 위한 표준 프로토콜
  - HDLC : 비트 위주의 데이터 링크 제어 프로토콜
  - X.25 : 패킷 교환망을 통한 인터페이스를 제공하는 프로토콜
  - RS-232C : 공중 전화 교환망을 통한 인터페이스를 제공하는 프로토콜

<br>

### 데이터 교환 방식/라우팅 C

<hr>
<br>

## 제품 소프트웨어 패키징
### 소프트웨어 패키징 B
### 릴리즈 노트 작성 B
### 디지털 저작권 관리 A
> 창작자가 가지는 배타적 독점적 권리로 타인의 침해를 받지 않을 고유한 권한

- 디지털 저작권 관리의 개요
  - 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용
  - 원본 콘텐츠가 아날로그인 경우 디지털로 변환 후 패키저에 의해 DRM 패키징을 수행
  - 콘텐츠의 크기가 작은 경우 : 사용자가 요청하는 시점에 실시간으로 패키징 수행
  - 콘텐츠의 크기가 큰 경우 : 미리 패키징을 수행한 후 배포
  - 암호화된 저작권자의 전자서명이 포함되고 해당 라이선스 정보가 클리어링 하우스에 등록

- 디지털 저작권 관리 용어
  - 클리어링 하우스 : 사용권한, 라이선스 발급, 사용량에 따른 결제 관리 등을 수행
  - 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
  - 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램
  - 콘텐츠 분배자 : 암호화된 콘텐츠를 유통하는 곳이나 사람
  - 콘텐츠 소비자 : 콘텐츠를 구매하여 사용하는 주체
  - DRM 컨트롤러 : 배포된 콘텐츠의 이용 권한을 통제하는 프로그램
  - 보안 컨테이너 : 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치

- 디지털 저작권 관리의 기술 요소
  - 암호화 : 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
  - 키 관리 : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술
  - 암호화 팡리 생성 : 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술
  - 식별 기술 : 콘텐츠에 대한 식별 체계 표현 기술
  - 저작권 표현 : 라이선스의 내용 표현 기술
  - 정책 관리 : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술
  - 크랙 방지 : 크랙에 의한 콘텐츠 사용 방지 기술
  - 인증 : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술

<br>

### 소프트웨어 설치 메뉴얼 작성 C
### 소프트웨어 사용자 메뉴얼 작성 C
### 소프트웨어 버전 등록 B
### 소프트웨어 버전 관리 도구 A
- 공유 폴더 방식
  - 로컬 컴퓨터의 공유 폴더에 저장되어 관리되는 방식
  - 종류 : SCCS, RCS, PVCS, QVCS
  
- 클라이언트/서버 방식
  - 중앙 시스템(서버)에 저장되어 관리되는 방식
  - 모든 버전 관리는 서버에서 수행
  - 종류 : CVS, SVN, CVSNT, Clear Case, CMVC, Perforce

- 분산 저장소 방식
  - 하나의 원격 저장소와 분산된 개발자 PC의 로컬 저장소에 함께 저장되어 관리되는 방식
  - 종류 : Git, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM

- Subversion(서브버전, SVN)
  - CVS를 개선한 것
  - 클라이언트/서버 구조로 서버에는 최신 버전의 파일들과 변경 내역이 관리
  - 변경 내용을 서버에 반영함
  - 모든 개발 작업은 trunk 디렉터리에서 수행되고 추가 작업은 branches 디렉터리 안에 별도의 디렉터리를 만들어 작업을 완료하고 trunk 디렉터리와 병합한다.
  - 커밋할 때마다 리비전이 1씩 증가한다.
  - CVS의 단점인 파일이나 디렉터리 이름의 변경, 이동 등이 가능

- Git
  - 분산 버전 관리 시스템으로 2개의 저장소, 지역 및 원격 저장소가 존재
  - 지역 저장소 : 개발자들이 실제 개발을 진행하는 장소로 버전 관리가 수행
  - 원격 저장소 : 여러 사람들이 협업을 위해 버전을 공동 관리하는 곳
  - 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능
  - 브랜치를 이용하면 기본 버전 관리 틀에 영향을 주지 않으면서 다양한 형태의 기능 테스팅이 가능

<br>

### 빌드 자동화 도구 B